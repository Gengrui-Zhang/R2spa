---
title: "2S-PA with Interaction"
author: "Hok Chio (Mark) Lai"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tspa-interaction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

From https://www.mdpi.com/2624-8611/3/3/24

```{r}
library(lavaan)
library(semTools)
library(R2spa)
library(dplyr)
dat <- read.csv("https://osf.io/download/grwn2/")
```

# Unconstrained Product Indicator

```{r}
modME <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3


tip ~ tvalue + sources 

'

fitME <- sem(modME, data = dat, std.lv = TRUE, estimator = "mlr")
summary(fitME, fit.measure = TRUE)

## Compute product indicators (double mean centering)

#create names
#not required, but makes syntax easier to write
tvalue <- paste0("t", 1:4)
sources <- paste0("s", 1:5)

intNames <- paste0(rep(tvalue, each = length(sources)), sources)

dat3 <- indProd(dat, var1 = c("t1", "t2", "t3", "t4"),
                var2 = c("s1", "s2", "s3", "s4", "s5"),
                match = FALSE, doubleMC = TRUE,
                namesProd = intNames)

## Mean Centering interaction model

modintMC <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3

int =~ t1s1 + t1s2 + t1s3 + t1s4 + t1s5 +        
       t2s1 + t2s2 + t2s3 + t2s4 + t2s5 + 
       t3s1 + t3s2 + t3s3 + t3s4 + t3s5 + 
       t4s1 + t4s2 + t4s3 + t4s4 + t4s5 


tip ~ tvalue + sources + int

#Residual covariances between terms from the same indicator 
#covariances between the same indicator are constrained to equality
t1s1 ~~ th1*t1s2 + th1*t1s3 + th1*t1s4 + th1*t1s5
t1s2 ~~ th1*t1s3 + th1*t1s4 + th1*t1s5
t1s3 ~~ th1*t1s4 + th1*t1s5
t1s4 ~~ th1*t1s5

t2s1 ~~ th2*t2s2 + th2*t2s3 + th2*t2s4 + th2*t2s5
t2s2 ~~ th2*t2s3 + th2*t2s4 + th2*t2s5
t2s3 ~~ th2*t2s4 + th2*t2s5
t2s4 ~~ th2*t2s5

t3s1 ~~ th3*t3s2 + th3*t3s3 + th3*t3s4 + th3*t3s5
t3s2 ~~ th3*t3s3 + th3*t3s4 + th3*t3s5
t3s3 ~~ th3*t3s4 + th3*t3s5
t3s4 ~~ th3*t3s5

t4s1 ~~ th4*t4s2 + th4*t4s3 + th4*t4s4 + th4*t4s5
t4s2 ~~ th4*t4s3 + th4*t4s4 + th4*t4s5
t4s3 ~~ th4*t4s4 + th4*t4s5
t4s4 ~~ th4*t4s5

t1s1 ~~ th5*t2s1 + th5*t3s1 + th5*t4s1 
t2s1 ~~ th5*t3s1 + th5*t4s1 
t3s1 ~~ th5*t4s1 

t1s2 ~~ th6*t2s2 + th6*t3s2 + th6*t4s2 
t2s2 ~~ th6*t3s2 + th6*t4s2 
t3s2 ~~ th6*t4s2 

t1s3 ~~ th7*t2s3 + th7*t3s3 + th7*t4s3 
t2s3 ~~ th7*t3s3 + th7*t4s3 
t3s3 ~~ th7*t4s3 

t1s4 ~~ th8*t2s4 + th8*t3s4 + th8*t4s4 
t2s4 ~~ th8*t3s4 + th8*t4s4 
t3s4 ~~ th8*t4s4 

t1s5 ~~ th9*t2s5 + th9*t3s5 + th9*t4s5 
t2s5 ~~ th9*t3s5 + th9*t4s5 
t3s5 ~~ th9*t4s5 
'

fitintMC <- sem(modintMC, data = dat3, std.lv = TRUE, meanstructure = TRUE)
summary(fitintMC, fit.measure = TRUE, standardized = TRUE)
```

```{r upi function}
# Testing
df <- read.csv("https://osf.io/download/grwn2/")
model <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
tip ~ tvalue + sources + tvalue:sources
'
summary(upi(data = df,
            model = model),
        fit.measure = TRUE,
        standardized = TRUE)
```

# Reliability-adjusted Product Indicator

```{r}
PE <- parameterEstimates(fitintMC)
tvalues <- c("t1", "t2", "t3", "t4")
sources <- c("s1", "s2", "s3", "s4", "s5")
tips <- c("tip1", "tip2", "tip3")
int <- names(dat3[, 14:33])

# Sum of factor loadings
tvalues_lambda <- sum(PE[match(tvalues, PE$rhs), "est"])
sources_lambda <- sum(PE[match(sources, PE$rhs), "est"])
tips_lambda <- sum(PE[match(tips, PE$rhs), "est"])
int_lambda <- sum(PE[match(int, PE$rhs), "est"])

# Sum of error variances and se
PE_vcov <- PE[PE$op == "~~", ]
PE_vcov <- PE_vcov[PE_vcov$label == "", ]
tvalues_error <- sum(PE_vcov[match(tvalues, PE_vcov$rhs), "est"])
sources_error <- sum(PE_vcov[match(sources, PE_vcov$rhs), "est"])
tips_error <- sum(PE_vcov[match(tips, PE_vcov$rhs), "est"])
int_error <- sum(PE_vcov[match(int, PE_vcov$rhs), "est"])

tvalues_se <- sqrt(tvalues_error)
sources_se <- sqrt(sources_error)
tips_se <- sqrt(tips_error)
int_se <- sqrt(int_error)

# Sum of item scores
dat3_sum <- dat3 %>% 
  mutate(tvalues_sum = rowSums(dat3[, tvalues]),
         sources_sum = rowSums(dat3[, sources]),
         tips_sum = rowSums(dat3[, tips]),
         int_sum = rowSums(dat3[, int]))

# Single-indicator Model

model_rapi <- "
              tvalue =~ 2.987473*tvalues_sum
              sources =~ 3.989224*sources_sum
              tip =~ 1.328669*tips_sum
              int =~ 12.92162*int_sum
              
              # Constrain the errors
              tvalues_sum ~~ 1.70026*tvalues_sum
              sources_sum ~~ 3.55476*sources_sum
              tips_sum ~~ 2.498348*tips_sum
              int_sum ~~ 21.61033*int_sum
              
              # regressions
              tip ~ tvalue + sources + int
              "

fit_rapi <- sem(model_rapi, data = dat3_sum)
summary(fit_rapi, standardized = TRUE)
```


# 2S-PA

```{r}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(dat, model = mod_cfa, method = "Bartlett", std.lv = TRUE)
```

```{r}
# Obtain factor product
fs_dat$fs_int <- fs_dat$fs_tvalue * fs_dat$fs_sources
# Centering the product variable
fs_dat$fs_int <- fs_dat$fs_int - mean(fs_dat$fs_int)
```

From equation (7) of Hsiao et al. (2018, doi: 10.1177/0013164416679877)

```{r}
fs_dat$fs_int_se <- sqrt(1 * 0.1219141 + 1 * 0.2024207 + 0.1219141 * 0.2024207)
```

```{r}
modinttspa <- '
# latent variables (indicated by factor scores)
tvalue =~ fs_tvalue
sources =~ fs_sources
tip =~ fs_tip
int =~ fs_int

# constrain the errors
fs_tvalue ~~ 0.1219141 * fs_tvalue
fs_sources ~~ 0.2024207 * fs_sources
fs_int ~~ 0.3490127 * fs_int
fs_tip ~~ 0.694483 * fs_tip

# regressions
tip ~ tvalue + sources + int
'
fitinttspa <- sem(modinttspa, data = fs_dat)
summary(fitinttspa, standardized = TRUE)
```

The model seems working pretty well!

```{r}
fitMC_pars <- parameterEstimates(fitintMC)
fitinttspa_pars <- parameterEstimates(fitinttspa)
``` 

```{r tspa function with interaction}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(dat, model = mod_cfa, method = "Bartlett", std.lv = TRUE)

fit <- tspa(model = "tip ~ tvalue + sources + tvalue:sources",
             data = fs_dat,
             se = list(tvalue = 0.349162, sources =  0.4499119,
                       tip = 0.8333564))

summary(fit, standardized = TRUE)
cat(attributes(fit)$tspaModel)
```

# Using factor scores without contraining measurement errors

```{r}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(dat, model = mod_cfa, method = "Bartlett", std.lv = TRUE)

# Obtain factor product
fs_dat$fs_int <- fs_dat$fs_tvalue * fs_dat$fs_sources
# Centering the product variable
fs_dat$fs_int <- fs_dat$fs_int - mean(fs_dat$fs_int)

modinttspa <- '
# latent variables (indicated by factor scores)
tvalue =~ fs_tvalue
sources =~ fs_sources
tip =~ fs_tip
int =~ fs_int

# regressions
tip ~ tvalue + sources + int
'
fitinttspa <- sem(modinttspa, data = fs_dat)
summary(fitinttspa, standardized = TRUE)
```




