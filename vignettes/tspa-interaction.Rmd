---
title: "2S-PA with Interaction"
author: "Jimmy Zhang, Hok Chio (Mark) Lai"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tspa-interaction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

From https://www.mdpi.com/2624-8611/3/3/24

```{r}
library(lavaan)
library(semTools)
library(R2spa)
library(dplyr)
library(nlsem)
devtools::load_all(".")
```

# UPI (Unconstrained Product Indicator)

An example of using UPI to conduct latent interaction estimation below is based on the example from Schoemann $\&$ Jorgensen (2021):

```{r}
  # Extract example data file online
  df <- read.csv("https://osf.io/download/grwn2/")
  df <- df[,-1]
  
  # Create product indicators using DMC
  tvalue <- paste0("t", 1:4)
  sources <- paste0("s", 1:5)
  intNames <- paste0(rep(tvalue, each = length(sources)), sources)
  mod_df <- indProd(df, 
                  var1 = c("t1", "t2", "t3", "t4"),
                  var2 = c("s1", "s2", "s3", "s4", "s5"),
                  match = FALSE, meanC = T, 
                  residualC = F, doubleMC = T,
                  namesProd = intNames)
  
  # Create the model syntax with local independence
  mod_upi <- '
  tvalue =~ t1 + t2 + t3 + t4
  sources =~ s1 + s2 + s3 + s4 + s5
  tip =~ tip1 + tip2 + tip3
  
  int =~ t1s1 + t1s2 + t1s3 + t1s4 + t1s5 +        
         t2s1 + t2s2 + t2s3 + t2s4 + t2s5 + 
         t3s1 + t3s2 + t3s3 + t3s4 + t3s5 + 
         t4s1 + t4s2 + t4s3 + t4s4 + t4s5 
  
  tip ~ b1*tvalue + b2*sources + b3*int
  
  #Residual covariances between terms from the same indicator 
  #covariances between the same indicator are constrained to equality
  t1s1 ~~ th1*t1s2 + th1*t1s3 + th1*t1s4 + th1*t1s5
  t1s2 ~~ th1*t1s3 + th1*t1s4 + th1*t1s5
  t1s3 ~~ th1*t1s4 + th1*t1s5
  t1s4 ~~ th1*t1s5
  
  t2s1 ~~ th2*t2s2 + th2*t2s3 + th2*t2s4 + th2*t2s5
  t2s2 ~~ th2*t2s3 + th2*t2s4 + th2*t2s5
  t2s3 ~~ th2*t2s4 + th2*t2s5
  t2s4 ~~ th2*t2s5
  
  t3s1 ~~ th3*t3s2 + th3*t3s3 + th3*t3s4 + th3*t3s5
  t3s2 ~~ th3*t3s3 + th3*t3s4 + th3*t3s5
  t3s3 ~~ th3*t3s4 + th3*t3s5
  t3s4 ~~ th3*t3s5
  
  t4s1 ~~ th4*t4s2 + th4*t4s3 + th4*t4s4 + th4*t4s5
  t4s2 ~~ th4*t4s3 + th4*t4s4 + th4*t4s5
  t4s3 ~~ th4*t4s4 + th4*t4s5
  t4s4 ~~ th4*t4s5
  
  t1s1 ~~ th5*t2s1 + th5*t3s1 + th5*t4s1 
  t2s1 ~~ th5*t3s1 + th5*t4s1 
  t3s1 ~~ th5*t4s1 
  
  t1s2 ~~ th6*t2s2 + th6*t3s2 + th6*t4s2 
  t2s2 ~~ th6*t3s2 + th6*t4s2 
  t3s2 ~~ th6*t4s2 
  
  t1s3 ~~ th7*t2s3 + th7*t3s3 + th7*t4s3 
  t2s3 ~~ th7*t3s3 + th7*t4s3 
  t3s3 ~~ th7*t4s3 
  
  t1s4 ~~ th8*t2s4 + th8*t3s4 + th8*t4s4 
  t2s4 ~~ th8*t3s4 + th8*t4s4 
  t3s4 ~~ th8*t4s4 
  
  t1s5 ~~ th9*t2s5 + th9*t3s5 + th9*t4s5 
  t2s5 ~~ th9*t3s5 + th9*t4s5 
  t3s5 ~~ th9*t4s5 
  '

  # Fit the model and summarize the result
  fit_upi <- sem(mod_upi, mod_df)
  summary(fit_upi, fit.measure = TRUE, standardized = TRUE)
```

Fitting the same model with `upi()` function:

```{r using upi}
  # Modified model syntax
  mod_upi <- "
          tvalue =~ t1 + t2 + t3 + t4
          sources =~ s1 + s2 + s3 + s4 + s5
          tip =~ tip1 + tip2 + tip3
          
          tip ~ b1*tvalue + b2*sources + b3*tvalue:sources
          
          tvalue ~~ v1*tvalue
          sources ~~ v2*sources
          beta1 := b1*sqrt(v1)
          beta2 := b2*sqrt(v2)
          beta3 := b3*sqrt(v1)*sqrt(v2)
          "
  # Fit the model using upi()
  fit_upi <- upi(mod_upi, mod_df, mode = "all")
  summary(fit_upi, fit.measure = TRUE, standardized = TRUE)
```

# Reliability-adjusted Product Indicator

Manual steps of using The RAPI method to conduct latent interaction estimation with details:

## Constraining on latent variables

```{r}
  PE <- parameterEstimates(fit_upi)
  tvalues <- c("t1", "t2", "t3", "t4")
  sources <- c("s1", "s2", "s3", "s4", "s5")
  tips <- c("tip1", "tip2", "tip3")
  
  # Sum of factor loadings
  tvalues_lambda <- sum(PE[match(tvalues, PE$rhs), "est"])
  sources_lambda <- sum(PE[match(sources, PE$rhs), "est"])
  tips_lambda <- sum(PE[match(tips, PE$rhs), "est"])
  
  # Sum of error variances and se
  PE_vcov <- PE[PE$op == "~~", ]
  PE_vcov <- PE_vcov[PE_vcov$label == "", ]
  tvalues_error <- sum(PE_vcov[match(tvalues, PE_vcov$rhs), "est"])
  sources_error <- sum(PE_vcov[match(sources, PE_vcov$rhs), "est"])
  tips_error <- sum(PE_vcov[match(tips, PE_vcov$rhs), "est"])
  
  tvalues_se <- sqrt(tvalues_error)
  sources_se <- sqrt(sources_error)
  tips_se <- sqrt(tips_error)
  
  # Sum of item scores
  mod_df <- df %>% 
    mutate(tvalues_sum = rowSums(df[, tvalues]),
           tsum_centered = tvalues_sum - mean(tvalues_sum, na.rm = T),
           sources_sum = rowSums(df[, sources]),
           ssum_centered = sources_sum - mean(sources_sum, na.rm = T),
           tips_sum = rowSums(df[, tips]),
           tips_sum_centered = tips_sum - mean(tips_sum, na.rm = T),
           int = tsum_centered*ssum_centered,
           int_centered = int - mean(int, na.rm = T))
  
  int_var <- tvalues_lambda^2*sources_error + 
    sources_lambda^2*tvalues_error + 
    sources_error*tvalues_error 
  
  # Single-indicator Model
  
  mod_rapi <- "
                tvalue =~ 2.987473*tsum_centered
                sources =~ 3.989224*ssum_centered
                tip =~ 1.328669*tips_sum_centered
                product_ind =~ 2.987473*3.989224*int_centered
                
                # Constrain the errors
                tsum_centered ~~ 1.70026*tsum_centered
                ssum_centered ~~ 3.55476*ssum_centered
                tips_sum_centered ~~ 2.498348*tips_sum_centered
                int_centered ~~ 64.82799*int_centered
                
                # regressions
                tip ~ b1*tvalue + b2*sources + b3*product_ind
  
                tvalue ~~ v1*tvalue
                sources ~~ v2*sources
                product_ind ~~ v3*product_ind

                # Define Standardized Coefficients
                beta1 := b1 * sqrt(v1)
                beta2 := b2 * sqrt(v2)
                beta3 := b3 * sqrt(v1) * sqrt(v2)"

  fit_rapi <- sem(mod_rapi, 
                  data = mod_df[, c("tsum_centered", "ssum_centered", "tips_sum_centered", "int_centered")])
  summary(fit_rapi, standardized = TRUE)
```

## Constraining on factor loadings

```{r}
# Compute centered sum score
  # df$tvalue_centered <- rowSums(df[, c("t1", "t2", "t3", "t4")]) - mean(rowSums(df[, c("t1", "t2", "t3", "t4")]), na.rm = T)
  # df$sources_centered <- rowSums(df[, c("s1", "s2", "s3", "s4", "s5")]) - mean(rowSums(df[, c("s1", "s2", "s3", "s4", "s5")]), na.rm = T)
  # df$tip_centered <- rowSums(df[, c("tip1", "tip2", "tip3")]) - mean(rowSums(df[, c("tip1", "tip2", "tip3")]), na.rm = T)
  # df$int_centered <- df$tvalue_centered*df$sources_centered
  # df$int_centered <- df$int_centered - mean(df$int_centered, na.rm = T)
  
  df <- read.csv("https://osf.io/download/grwn2/")
  df <- df[,-1]
  
  df_centered <- df %>% mutate(across(everything(), ~ . - mean(., na.rm = T)))
  df_centered$tvalue_centered <- rowSums(df_centered[, c("t1", "t2", "t3", "t4")])
  df_centered$sources_centered <- rowSums(df_centered[, c("s1", "s2", "s3", "s4", "s5")])
  df_centered$tip_centered <- rowSums(df_centered[, c("tip1", "tip2", "tip3")]) 
  df_centered$int_centered <- df_centered$tvalue_centered*df_centered$sources_centered
  
  # Error variances
  PE_vcov <- PE[PE$op == "~~", ]
  PE_vcov <- PE_vcov[PE_vcov$label == "", ]
  
  rel_tvalue <- unlist(as.vector(psych::alpha(df[, c("t1", "t2", "t3", "t4")])$total["raw_alpha"]))
  rel_sources <- unlist(as.vector(psych::alpha(df[, c("s1", "s2", "s3", "s4", "s5")])$total["raw_alpha"]))
  rel_tip <- unlist(as.vector(psych::alpha(df[, c("tip1", "tip2", "tip3")])$total["raw_alpha"]))
  
  # error_tvalue <- (1 - rel_tvalue)*var(df$tvalue_centered, na.rm = T)
  # error_sources <- (1 - rel_sources)*var(df$sources_centered, na.rm = T)
  # error_tips <- (1 - rel_tip)*var(df$tip_centered, na.rm = T)
  # error_int <- rel_tvalue*var(df$tvalue_centered, na.rm = T)*(1 - rel_sources)*var(df$sources_centered, na.rm = T) + rel_sources*var(df$sources_centered, na.rm = T)*(1 - rel_tvalue)*var(df$tvalue_centered, na.rm = T) +
  #     (1 - rel_sources)*var(df$sources_centered, na.rm = T)*(1 - rel_tvalue)*var(df$tvalue_centered, na.rm = T)
  # 
  # var_int <- var(df$int_centered, na.rm = T) - var(df$tvalue_centered, na.rm = T)*rel_tvalue*error_sources - var(df$sources_centered, na.rm = T)*rel_sources*error_tvalue - error_sources*error_tvalue
  
  
  # Single-indicator Model
  
  mod_rapi <- "
                tvalue =~ 1*tvalue_centered
                sources =~ 1*sources_centered
                tip =~ 1*tip_centered
                int =~ 1*int_centered
                
                # Error variance
                tvalue_centered ~~ ve1*tvalue_centered
                sources_centered ~~ ve2*sources_centered
                int_centered ~~ ve3*int_centered
                tip_centered ~~ vey*tip_centered
                
                # regression
                tip ~ b1*tvalue + b2*sources + b3*int 
                
                # True score variance
                tvalue ~~ veta1*tvalue
                sources ~~ veta2*sources
                int ~~ veta3*int
                tip ~~ vetay*tip 
                
                # Total variance
                ve1 == veta1*(1 - 0.8351241)/0.8351241
                ve2 == veta2*(1 - 0.814727)/0.814727
                ve3 == ve1*veta2 + ve2*veta1 + ve1*ve2 
                vey == vetay*(1 - 0.4601677)/0.4601677
                
                # Define Standardized Coefficients
                beta1 := b1*sqrt(veta1)
                beta2 := b2*sqrt(veta2)
                beta3 := b3*sqrt(veta1)*sqrt(veta2)
                "
  
  fit_rapi <- sem(mod_rapi, 
                  data = df_centered)
  summary(fit_rapi)
```


```{r rapi function}
# Testing
  df <- read.csv("https://osf.io/download/grwn2/")
  df <- df[,-1]
  mod_rapi <- '
  tvalue =~ t1 + t2 + t3 + t4
  sources =~ s1 + s2 + s3 + s4 + s5
  tip =~ tip1 + tip2 + tip3
  tip ~ tvalue + sources + tvalue:sources
  '
  rapi_fit <- rapi_rel(data = df,
                       model = mod_rapi,
                       rel = "alpha")
  summary(rapi_fit)
```

# 2S-PA

```{r}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(df, model = mod_cfa, method = "Bartlett", std.lv = TRUE)
```

```{r}
# Obtain factor product
fs_dat$fs_int <- fs_dat$fs_tvalue * fs_dat$fs_sources
# Centering the product variable
fs_dat$fs_int <- fs_dat$fs_int - mean(fs_dat$fs_int)
```

From equation (7) of Hsiao et al. (2018, doi: 10.1177/0013164416679877)

```{r}
fs_dat$fs_int_se <- sqrt(1 * 0.1219141 + 1 * 0.2024207 + 0.1219141 * 0.2024207)
```

```{r}
modinttspa <- '
# latent variables (indicated by factor scores)
tvalue =~ fs_tvalue
sources =~ fs_sources
tip =~ fs_tip
int =~ fs_int

# constrain the errors
fs_tvalue ~~ 0.1219141 * fs_tvalue
fs_sources ~~ 0.2024207 * fs_sources
fs_int ~~ 0.3490127 * fs_int
fs_tip ~~ 0.694483 * fs_tip

# regressions
tip ~ b1*tvalue + b2*sources + b3*int

              tvalue ~~ v1*tvalue
              sources ~~ v2*sources
              int ~~ v3*int
              
              # Define Standardized Coefficients
              beta1 := b1 * sqrt(v1)
              beta2 := b2 * sqrt(v2)
              beta3 := b3 * sqrt(v1) * sqrt(v2)
'
fitinttspa <- sem(modinttspa, data = fs_dat)
summary(fitinttspa, standardized = TRUE)
```

The model seems working pretty well!

```{r}
fitMC_pars <- parameterEstimates(fitintMC)
fitinttspa_pars <- parameterEstimates(fitinttspa)
``` 

```{r tspa function with interaction}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(dat, model = mod_cfa, method = "Bartlett", std.lv = TRUE)

fit <- tspa(model = "tip ~ tvalue + sources + tvalue:sources",
             data = fs_dat,
             se = list(tvalue = 0.349162, sources =  0.4499119,
                       tip = 0.8333564))

summary(fit, standardized = TRUE)
cat(attributes(fit)$tspaModel)
```

# Using factor scores without contraining measurement errors

```{r}
mod_cfa <- '
tvalue =~ t1 + t2 + t3 + t4
sources =~ s1 + s2 + s3 + s4 + s5
tip =~ tip1 + tip2 + tip3
'
# Obtain factor scores
fs_dat <- get_fs(dat, model = mod_cfa, method = "Bartlett", std.lv = TRUE)

# Obtain factor product
fs_dat$fs_int <- fs_dat$fs_tvalue * fs_dat$fs_sources
# Centering the product variable
fs_dat$fs_int <- fs_dat$fs_int - mean(fs_dat$fs_int)

modinttspa <- '
# latent variables (indicated by factor scores)
tvalue =~ fs_tvalue
sources =~ fs_sources
tip =~ fs_tip
int =~ fs_int

# regressions
tip ~ tvalue + sources + int
'
fitinttspa <- sem(modinttspa, data = fs_dat)
summary(fitinttspa, standardized = TRUE)
```

# Latent Moderated Structural Equations (LMS)

```{r}
lms <- specify_sem(num.x = 9, num.y = 3, num.xi = 2, num.eta = 1, xi = "x1-x4,x5-x9",
  eta = "y1-y3", interaction = "xi1:xi2")

start <- runif(count_free_parameters(lms))

dat_lms <- dat %>% 
  slice(1:1000) %>%
  select(-X) %>%
  na.omit()

colnames(dat_lms) <- c(paste0(rep("x", 9), 1:9), paste0(rep("y", 3), 1:3))

res_lms <- em(lms, dat_lms, start, convergence = 0.1)
summary(res_lms)
plot(res_lms)
```

```{r}
model = '
          # Structural Model
            Y ~ b1*X + b2*M + b3*X:M
          
          # Define Standardized Coefficients
            X ~~ v1*X
            M ~~ v2*M
            beta1 := b1 * sqrt(v1)
            beta2 := b2 * sqrt(v2)
            beta3 := b3 * sqrt(v1) * sqrt(v2)
        '

model = '
          # Measurement Model
            X =~ x1 + x2 + x3
            M =~ m1 + m2 + m3
          # Structural Model
            Y ~ X + M + X:M
          '
```


