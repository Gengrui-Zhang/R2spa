---
title: "Vignette Title"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r}
library(lavaan)
library(R2spa)
```

## Simulate Data

```{r}
set.seed(1116)
# Low reliability, high SE for measurement parameters
num_obs <- 100
beta <- .7
Lambda <- matrix(c(.3, .5, .6, rep(0, 6), .6, .3, .5), ncol = 2)
Theta <- diag(.75, nrow(Lambda))
Psi <- matrix(c(1, beta, beta, 1), nrow = 2)
eta_delta <- MASS::mvrnorm(num_obs,
    mu = rep(0, sum(dim(Lambda))),
    Sigma = Matrix::bdiag(list(Psi, Theta)),
    empirical = TRUE
)
ind <- eta_delta[, 1:2] %*% t(Lambda) + eta_delta[, -(1:2)]
dat <- data.frame(ind)
names(dat) <- c(paste0("x", 1:3), paste0("y", 1:3))
```

## Approach 1: Joint Modeling

```{r}
mod <- "
  fy =~ y1 + y2 + y3
  fx =~ x1 + x2 + x3
  fy ~ fx
"
mjoint <- sem(mod, data = dat)
standardizedSolution(mjoint)
```

## Approach 2: Global SAM

```{r}
mgsam <- sam(mod, data = dat, sam.method = "global")
summary(mgsam)
standardizedSolution(mgsam)
```

## Approach 3: Local SAM

```{r}
mlsam <- sam(mod, data = dat)
summary(mlsam)
standardizedSolution(mlsam)  # same SE
```

## Approach 4: 2S-PA with both loading and error

```{r}
cfa_mod <- "
  fy =~ y1 + y2 + y3
  fx =~ x1 + x2 + x3
"
cfa_fit <- cfa(cfa_mod, std.lv = TRUE, data = dat)
fs <- get_fs_lavaan(cfa_fit, method = "Bartlett", vfsLT = TRUE)
m2spa1 <- tspa(" fy ~ fx",
    data = fs,
    fsT = attr(fs, "fsT"), fsL = attr(fs, "fsL")
)
standardizedSolution(m2spa1)
```

## Approach 5: 2S-PA with reliability constraints

```{r}
mod2 <- "
  fy =~ NA * fs_fy + ly * fs_fy
  fx =~ NA * fs_fx + lx * fs_fx
  fs_fy ~~ ev1 * fs_fy
  fs_fx ~~ ev2 * fs_fx
  fx ~~ 1 * fx
  fy ~ beta * fx
  fy ~~ dvy * fy
  # constraints
  ev2 == 1.071429 * lx^2
  1 == beta^2 + dvy
  ev1 == 1.071429 * ly^2
"
m2spa2 <- sem(mod2, data = fs)
standardizedSolution(m2spa2)
# Numeric Hessian
library(numDeriv)
mod2 <- "
  fy =~ NA * fs_fy + ly * fs_fy
  fx =~ NA * fs_fx + lx * fs_fx
  fs_fy ~~ ev1 * fs_fy
  fs_fx ~~ ev2 * fs_fx
  fx ~~ 1 * fx
  fy ~ beta * fx
  fy ~~ dvy * fy
  # constraints
  ev2 == ep2 * lx^2
  1 == beta^2 + dvy
  ev1 == ep1 * ly^2
"
get_grad <- function(ep) {
    mod_tmp <- gsub("ep2", ep[2], mod2)
    mod_tmp <- gsub("ep1", ep[1], mod_tmp)
    lavInspect(sem(mod_tmp, data = fs),
               what = "gradient")
}
d_par_ev <- numDeriv::jacobian(get_grad, diag(attr(fs, "fsT")))
# Corrected SE
v_ev <- attr(fs, "vfsLT")[c(5, 7), c(5, 7)]
i_par <- lavInspect(m2spa2, what = "information")
inv_i_par_jac <- lavInspect(m2spa2, what = "inverted.information") %*% d_par_ev
vc_corrected <- vcov(m2spa2) + inv_i_par_jac %*% v_ev %*% t(inv_i_par_jac)
# Constraints for standardized solution (Bartlett scores):
# - loadings = sqrt(1 / (1 + EV))
# - Error = 1 - loadings^2 = EV / (1 + EV)
# - Variances of fs (unstandardized) can be freely estimated
# May need the means if mean structure is used
implied_mm <- function(pars) {
  beta <- pars[1]
  vfs_fy <- pars[2]
  vfs_fx <- pars[3]
  vlat <- diag(2)
  vlat[2, 1] <- vlat[1, 2] <- beta

}
```

## Comparisons

```{r}
cbind(joint = unlist(standardizedSolution(mjoint)[7, c("est.std", "se")]),
      `sam-g` = unlist(standardizedSolution(mgsam)[7, c("est.std", "se")]),
      `sam-l` = unlist(standardizedSolution(mlsam)[7, c("est.std", "se")]),
      `2spa-ev` = unlist(standardizedSolution(m2spa1)[8, c("est.std", "se")]),
      `2spa-rel` = unlist(standardizedSolution(m2spa2)[6, c("est.std", "se")]),
      `2spa-rel-cor` = c(.70, sqrt(diag(vc_corrected)[5])))
```

## Simulation

```{r}
num_sim <- 500
est <- se <- matrix(nrow = 5, ncol = num_sim)
for (r in seq_len(num_sim)) {
    # Data generation
    eta_delta <- MASS::mvrnorm(num_obs,
        mu = rep(0, sum(dim(Lambda))),
        Sigma = Matrix::bdiag(list(Psi, Theta))
    )
    ind <- eta_delta[, 1:2] %*% t(Lambda) + eta_delta[, -(1:2)]
    dat <- data.frame(ind)
    names(dat) <- c(paste0("x", 1:3), paste0("y", 1:3))

    # Joint Model
    mod <- "
  fy =~ y1 + y2 + y3
  fx =~ x1 + x2 + x3
  fy ~ fx
    "
    mjoint <- sem(mod, data = dat)
    joint_est <- standardizedSolution(mjoint)[7, ]

    # SAM
    ## Global
    mgsam <- sam(mod, data = dat, sam.method = "global")
    gsam_est <- standardizedSolution(mgsam)[7, ]
    ## Local
    mlsam <- sam(mod, data = dat)
    lsam_est <- standardizedSolution(mlsam)[7, ]

    # 2S-PA
    ## Error
    cfa_mod <- "
  fy =~ y1 + y2 + y3
  fx =~ x1 + x2 + x3
    "
    cfa_fit <- cfa(cfa_mod, std.lv = TRUE, data = dat,
                   bounds = "pos.ov.var")
    fs <- get_fs_lavaan(cfa_fit, method = "Bartlett", vfsLT = TRUE)
    m2spa1 <- tspa(" fy ~ fx",
        data = fs,
        fsT = attr(fs, "fsT"), fsL = attr(fs, "fsL")
    )
    tspa1_est <- standardizedSolution(m2spa1)[8, ]
    ## Reliability
    mod2 <- "
  fy =~ NA * fs_fy + ly * fs_fy
  fx =~ NA * fs_fx + lx * fs_fx
  fs_fy ~~ ev1 * fs_fy
  fs_fx ~~ ev2 * fs_fx
  fx ~~ 1 * fx
  fy ~ beta * fx
  fy ~~ dvy * fy
  # constraints
  ev2 == ep2 * lx^2
  1 == beta^2 + dvy
  ev1 == ep1 * ly^2
    "
    ep <- diag(attr(fs, "fsT"))
    mod_tmp <- gsub("ep2", ep[2], mod2)
    mod_tmp <- gsub("ep1", ep[1], mod_tmp)
    m2spa2 <- sem(mod_tmp, data = fs)
    tspa2_est <- standardizedSolution(m2spa2)[6, ]

    # Save results
    est[, r] <- c(joint_est[["est.std"]],
                  gsam_est[["est.std"]],
                  lsam_est[["est.std"]],
                  tspa1_est[["est.std"]],
                  tspa2_est[["est.std"]])
    se[, r] <- c(joint_est[["se"]],
                 gsam_est[["se"]],
                 lsam_est[["se"]],
                 tspa1_est[["se"]],
                 tspa2_est[["se"]])
}
```