---
title: "Factor Scores May Not Be Invariant"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{factor-scores-not-invariant}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
  - \DeclareMathOperator{\Var}{\mathrm{Var}}
  - \DeclareMathOperator{\E}{\mathrm{E}}
  - \newcommand{\bv}[1]{\boldsymbol{\mathbf{#1}}}  %APA-consistent bold
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette shows that factor scores based on a partial invariance model may not be invariant.

```{r load-pkg, message = FALSE}
library(MASS)
library(lavaan)
library(R2spa)
```

```{r}
lambda1 <- seq(.9, .7, length.out = 5)
lambda2 <- c(lambda1[1], 1, lambda1[3:5])
cov1 <- tcrossprod(lambda1) + diag(.5, 5)
dimnames(cov1) <- list(paste0("y", 1:5), paste0("y", 1:5))
nu1 <- seq(-0.5, 0.5, length.out = 5)
nu2 <- c(nu1[1], 0.25, nu1[3:4], 0.3)
mean1 <- nu1
cov2 <- tcrossprod(lambda2) * 1.3 + diag(.5, 5)
dimnames(cov2) <- list(paste0("y", 1:5), paste0("y", 1:5))
mean2 <- nu2
# Simulate data
y1 <- MASS::mvrnorm(200, mu = mean1, Sigma = cov1, empirical = TRUE)
y2 <- MASS::mvrnorm(200, mu = mean2, Sigma = cov2, empirical = TRUE)
y_dat <- rbind(cbind(y1, group = 1), cbind(y2, group = 2))
```

```{r}
pmi_fit <- cfa("f =~ y1 + y2 + y3 + y4 + y5",
               data = y_dat,
               group = "group",
               group.equal = c("loadings", "intercepts"),
               group.partial = c("f=~y2", "y2~1", "y5~1"))
summary(pmi_fit)
```

Note the latent mean difference is zero. Now look at the factor scores

```{r}
# Regression score
pmi_fs <- get_fs(
  data = y_dat,
  "f =~ y1 + y2 + y3 + y4 + y5",
  group = "group",
  group.equal = c("loadings", "intercepts"),
  group.partial = c("f=~y2", "y2~1", "y5~1")
)
mean(pmi_fs[[1]]$fs_f)
mean(pmi_fs[[2]]$fs_f)
```

```{r}
# With external variable
lambda1 <- cbind(c(seq(.9, .7, length.out = 5), 0),
                 c(rep(0, 5), 1))
lambda2 <- cbind(c(lambda1[1], 1, lambda1[3:5], 0),
                 c(rep(0, 5), 1))
psi1 <- matrix(c(1, 0.5, 0.5, 1), nrow = 2)
cov1 <- lambda1 %*% psi1 %*% t(lambda1) + diag(c(rep(.5, 5), 0))
dimnames(cov1) <- list(c(paste0("y", 1:5), "z"), c(paste0("y", 1:5), "z"))
mean1 <- c(seq(-0.5, 0.5, length.out = 5), 0)
mean2 <- c(c(nu1[1], 0.25, nu1[3:4], 0.3), 0)
psi2 <- matrix(c(1.3, 0.5, 0.5, 1), nrow = 2)
cov2 <- lambda1 %*% psi2 %*% t(lambda1) + diag(c(rep(.5, 5), 0))
dimnames(cov2) <- list(c(paste0("y", 1:5), "z"), c(paste0("y", 1:5), "z"))
# Simulate data
y1 <- MASS::mvrnorm(200, mu = mean1, Sigma = cov1, empirical = TRUE)
y2 <- MASS::mvrnorm(200, mu = mean2, Sigma = cov2, empirical = TRUE)
y_dat <- rbind(cbind(y1, group = 1), cbind(y2, group = 2))
```

```{r}
pmi_fit <- sem("
f =~ y1 + y2 + y3 + y4 + y5
f ~ z
",
  data = y_dat,
  group = "group",
  group.equal = c("loadings", "intercepts"),
  group.partial = c("f=~y2", "y2~1", "y5~1")
)
summary(pmi_fit)
```

```{r}
# Regression score
pmi_fs <- get_fs(
  data = y_dat,
  "f =~ y1 + y2 + y3 + y4 + y5",
  group = "group",
  group.equal = c("loadings", "intercepts"),
  group.partial = c("f=~y2", "y2~1", "y5~1")
)
mean(pmi_fs[[1]]$fs_f)
mean(pmi_fs[[2]]$fs_f)
lm(pmi_fs[[1]]$fs_f ~ y_dat[y_dat[, "group"] == 1, "z"])
lm(pmi_fs[[2]]$fs_f ~ y_dat[y_dat[, "group"] == 2, "z"])
# This seems to be due to unequal variances. Would constraining the variances to be equal help?
```